
-----

### 核心思想：JavaScript 如何追踪正在运行的函数

这篇文章的核心思想是解释 **调用栈 (Call Stack)** 是 JavaScript 引擎用来追踪函数调用的一个基本机制。你可以把它想象成一叠盘子：

  * **后进先出 (LIFO - Last-In, First-Out)**：最后一个被放上去的盘子，是第一个被拿走的。同样，最后一个被调用的函数，是第一个执行完毕并被移除的。

调用栈只有一个主要任务：**记录当前程序执行到了哪个位置**。

### 调用栈的工作流程

1.  **全局执行上下文 (Global Execution Context)**：当一个 JavaScript 文件开始运行时，一个代表“全局”环境的执行上下文 (可以想象成一个代表`main()`函数的帧) 会被首先推入 (push) 到调用栈的底部。

2.  **函数调用 (Push)**：当你的代码调用一个函数时，一个新的“帧” (Frame) 会被创建并**推入**到调用栈的顶部。这个帧包含了该函数的所有局部变量和参数。

3.  **函数执行**：JavaScript 引擎总是执行位于调用栈**最顶部**的函数。

4.  **函数返回 (Pop)**：当最顶部的函数执行完毕（遇到 `return` 语句或执行到函数末尾），它的帧就会从调用栈中**弹出** (pop)，控制权交还给栈中下一个函数。

5.  **栈清空**：当所有代码都执行完毕，全局执行上下文也会从栈中弹出，调用栈变为空。

### 文章中的示例剖析

文章通过一个简单的 `add()` 和 `average()` 函数示例来展示这个过程：

```javascript
function add(a, b) {
    return a + b;
}

function average(a, b) {
    return add(a, b) / 2;
}

let x = average(10, 20);
```

这个过程在调用栈中的变化如下：

1.  **开始**：`main()` (或 `global()`) 帧入栈。
2.  **调用 `average(10, 20)`**：`average()` 帧被推入栈顶。
3.  **在 `average` 内部调用 `add(10, 20)`**：`add()` 帧被推入栈顶。
4.  **`add()` 执行完毕**：`add()` 返回 `30`，其帧从栈中弹出。
5.  **`average()` 继续执行**：它用 `add()` 返回的 `30` 完成计算 (`30 / 2`)，得到 `15`。
6.  **`average()` 执行完毕**：`average()` 返回 `15`，其帧从栈中弹出。
7.  **`main()` 继续执行**：将 `average()` 返回的 `15` 赋值给变量 `x`。
8.  **结束**：`main()` 执行完毕，其帧弹出，栈变为空。

### 关键概念：栈溢出 (Stack Overflow)

文章还提到了一个重要的错误：**栈溢出 (Stack Overflow)**。

  * **原因**：当调用栈被过多的函数帧填满，超出了其分配的内存大小时，就会发生这个错误。
  * **常见场景**：最常见的原因是**没有终止条件的递归函数**。函数会无休止地调用自身，导致帧不断地被推入栈中，直到栈被撑爆。

<!-- end list -->

```javascript
function foo() {
    foo(); // 无限递归
}
foo(); // 这会引发栈溢出
```

### 总结

这篇文章用清晰的图文和示例解释了 JavaScript 调用栈这个底层的、看不见但至关重要的概念。理解调用栈有助于你：

1.  **追踪代码执行流程**：明白函数是如何被依次调用和返回的。
2.  **调试错误**：当程序出错时，错误信息中显示的“堆栈跟踪 (stack trace)”其实就是调用栈在出错那一刻的快照，它告诉你错误发生在哪个函数的调用链中。
3.  **理解更高级的概念**：调用栈是理解 JavaScript 异步编程（如事件循环、回调队列）的基础。